(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{527:function(e,_,o){"use strict";o.r(_);var r=o(2),v=Object(r.a)({},(function(){var e=this,_=e.$createElement,o=e._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("将当前用户添加到 docker 用户组"),o("br"),e._v("\n为了避免每次使用 docker 命令都需要加上 sudo 权限，可以将当前用户加入安装中自动创建的 docker 用户组（可以参考 "),o("a",{attrs:{href:"https://docs.docker.com/engine/install/linux-postinstall/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),o("OutboundLink")],1),e._v("）")]),e._v(" "),o("div",{staticClass:"language-sh extra-class"},[o("pre",{pre:!0,attrs:{class:"language-sh"}},[o("code",[o("span",{pre:!0,attrs:{class:"token function"}},[e._v("sudo")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("usermod")]),e._v(" -aG "),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$USER")]),e._v("\n")])])]),o("p",[o("code",[e._v("docker->image->container")])]),e._v(" "),o("p",[e._v("docker version 查看 docker 是否安装完成")]),e._v(" "),o("h2",{attrs:{id:"镜像-images"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#镜像-images"}},[e._v("#")]),e._v(" 镜像（images）")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("docker pull ubuntu:20.04")]),e._v(" ：拉取一个镜像 docker pull 命令就是拉取一个镜像，注意镜像是名字冒号加上版本号")]),e._v(" "),o("li",[o("code",[e._v("docker images")]),e._v("  : 列出本地的所有镜像")]),e._v(" "),o("li",[o("code",[e._v("docker image rm ubuntu:20.04")]),e._v("  或  "),o("code",[e._v("docker rmi ubuntu:20.04")]),e._v(" ：删除镜像 ubuntu:20.04")]),e._v(" "),o("li",[o("code",[e._v("docker rmi -f $(docker images -aq)")]),e._v("  删除全部的镜像  "),o("code",[e._v("docker images -aq")]),e._v("  可以列出所有镜像的 ID")]),e._v(" "),o("li",[o("code",[e._v("docker [container] commit CONTAINER IMAGE_NAME:TAG")]),e._v(" ：创建某个 container  的镜像")]),e._v(" "),o("li",[o("code",[e._v("docker save -o ubuntu_20_04.tar ubuntu:20.04")]),e._v(" ：将镜像 ubuntu:20.04 导出到本地文件 ubuntu_20_04.tar 中 （用 scp 在不同服务器中传送 tar 数据包）")]),e._v(" "),o("li",[o("code",[e._v("docker load -i ubuntu_20_04.tar")]),e._v(" ：将镜像 ubuntu:20.04 从本地文件 ubuntu_20_04.tar 中加载出来，将一个 tar 变成一个 image")])]),e._v(" "),o("h2",{attrs:{id:"容器-container"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#容器-container"}},[e._v("#")]),e._v(" 容器 (container)")]),e._v(" "),o("p",[o("code",[e._v("[container]")]),e._v("  意思是使用命令的时候这个字段可选，一般使用的时候不加这个参数")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("docker [container] create -it ubuntu:20.04")]),e._v("  利用镜像 ubuntu:20.04 创建一个容器。根据一个模板创建出来一个服务器（容器），一个镜像可以创建很多个容器")]),e._v(" "),o("li",[o("code",[e._v("docker ps -a")]),e._v(" ：查看本地的所有容器，不加 -a 就是显示所有正在运行的容器")]),e._v(" "),o("li",[o("code",[e._v("docker [container] start CONTAINER")]),e._v(" ：启动容器， container 的位置可以加 ID，也可以加容器名字")]),e._v(" "),o("li",[o("code",[e._v("docker [container] stop CONTAINER")]),e._v(" ：停止容器")]),e._v(" "),o("li",[o("code",[e._v("docker [container] restart CONTAINER")]),e._v(" ：重启容器")]),e._v(" "),o("li",[o("code",[e._v("docker [contaienr] run -itd ubuntu:20.04")]),e._v(" ：创建并启动一个容器")]),e._v(" "),o("li",[o("code",[e._v("dcoker run")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("-it")]),e._v("  使用交互方式运行，进入容器查看内容")]),e._v(" "),o("li",[o("code",[e._v("-d")]),e._v("  后台方式运行，容器启动后，发现自己没有提供服务，就会立刻停止，")])])]),e._v(" "),o("li",[o("code",[e._v("docker [container] attach CONTAINER")]),e._v(" ：进入容器，相当于进入了一个服务器\n"),o("ul",[o("li",[o("code",[e._v("ctrl + P ++ ctrl + Q")]),e._v("  退出容器")]),e._v(" "),o("li",[o("code",[e._v("ctrl + d")]),e._v("  也可以退出容器，但是会将服务器关掉")])])]),e._v(" "),o("li",[o("code",[e._v("docker [container] exec CONTAINER COMMAND")]),e._v(" ：在容器中执行命令，只有当容器启动的时候，才可以执行命令， container 的位置填写名字或者 id，command 位置填写你要在这个容器中执行的命令，这个命令会将 执行的结果返回到命令行输出中\n"),o("ul",[o("li",[o("code",[e._v("docker exec -it container")]),e._v(" : 进入某一个容器，相比于 attach 多开了一个新的终端，可以进行操作，attach 进入容器正在执行的终端")])])]),e._v(" "),o("li",[o("code",[e._v("docker [container] rm CONTAINER")]),e._v(" ：删除容器， 注意和 rmi 的区别，rmi 删除一个镜像，rm 删除一个容器\n"),o("ul",[o("li",[o("code",[e._v("docker rm -f $(docker ps -aq)")]),e._v("  删除所有容器")]),e._v(" "),o("li",[o("code",[e._v("docker container prune")]),e._v(" ：删除所有已停止的容器 prune ：动词：修剪，剪裁，修整，精简，缩减")])])]),e._v(" "),o("li",[o("code",[e._v("docker export -o xxx.rar CONTAINER")]),e._v(" ：将容器 CONTAINER 导出到本地文件 xxx.tar 中，直接将容器打包，进行导入导出，跳过了打包到镜像的这一步\n"),o("ul",[o("li",[o("code",[e._v("chmod +r tmp.rar")]),e._v("  为 tmp.tar 增加一个可读权限")])])]),e._v(" "),o("li",[o("code",[e._v("docker import xxx.tar image_name:tag")]),e._v(" ：将本地文件 xxx.tar 导入成镜像，并同时将镜像命名为  "),o("code",[e._v("image_name:tag")])]),e._v(" "),o("li",[o("code",[e._v("docker export/import")]),e._v("  与  "),o("code",[e._v("docker save/load")]),e._v("  的区别：\n"),o("ul",[o("li",[o("code",[e._v("export/import")]),e._v("  会丢弃历史记录和元数据信息，仅保存容器当时的快照状态")]),e._v(" "),o("li",[o("code",[e._v("save/load")]),e._v("  会保存完整记录，但是体积更大")])])]),e._v(" "),o("li",[o("code",[e._v("docker top CONTAINER")]),e._v(" ：查看某个容器内的所有进程状态，当然也可以先 attach 到 docker 中，使用 top 命令查看，然后在 ctrl p ctrl q 挂起")]),e._v(" "),o("li",[o("code",[e._v("docker stats")]),e._v(" ：查看所有容器的统计信息，包括 CPU、内存、存储、网络等信息")]),e._v(" "),o("li",[o("code",[e._v("docker inspect CONTAINER_ID")]),e._v("  查看容器的信息， json 文件格式进行输出")]),e._v(" "),o("li",[o("code",[e._v("docker cp local_path CONTAINER:path 或 docker cp CONTAINER:path local_path")]),e._v(" ：在本地和容器间复制文件，就和 scp 在不同服务器之间复制文件一样，只是将 scp 换成了 docker cp，容器关闭之后也可以进行内容的复制")]),e._v(" "),o("li",[o("code",[e._v("docker rename CONTAINER1 CONTAINER2")]),e._v(" ：重命名容器，如果经常使用的话，就不用那个乱码名字了")]),e._v(" "),o("li",[o("code",[e._v("docker update CONTAINER --memory 500MB")]),e._v(" ：修改容器限制为 500MB，更多的修改在官网文档")]),e._v(" "),o("li",[o("code",[e._v("docker logs -tf --tail number CONTAINER_ID")]),e._v("  查看容器中的日志")])]),e._v(" "),o("h2",{attrs:{id:"新机连接"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#新机连接"}},[e._v("#")]),e._v(" 新机连接")]),e._v(" "),o("ol",[o("li",[e._v("scp 抄一个镜像 tar 到新的服务器")]),e._v(" "),o("li",[e._v("ssh 连接到新的服务器")]),e._v(" "),o("li",[o("code",[e._v("docker load -i dockerDemo_1_0.tar")]),e._v("  将那个镜像加载到 docker 镜像目录中")]),e._v(" "),o("li",[o("code",[e._v("docker run -p 20000:22 --name django -itd django:1.0")]),e._v("   创建并运行  "),o("code",[e._v("django:1.0")]),e._v("  镜像， "),o("code",[e._v("-p 20000:22")]),e._v("  是修改端口号映射，将容器中的 22 端口号映射到本地的 20000 端口号，因为本地的 22 端口号已经被用过了，本地需要登录 （服务器需要在网络安全组中放开 20000 端口）")]),e._v(" "),o("li",[o("code",[e._v("docker attach my_docker_server")])]),e._v(" "),o("li",[o("code",[e._v("passwd 111")]),e._v("  # 设置这一个 docker server 的 root 用户的密码为  "),o("code",[e._v("111")])]),e._v(" "),o("li",[o("code",[e._v("ctrl + p, ctrl + q")]),e._v(" , 将这个容器挂起")]),e._v(" "),o("li",[o("code",[e._v("ssh root@localhost -p 20000")]),e._v("  在这个新的服务器中，就可以使用 ssh 登录新创建的 docker 容器")]),e._v(" "),o("li",[e._v("可以在  "),o("code",[e._v(".ssh")]),e._v("  中添加与服务器相同的 ip 地址，但是需要多一行 port 属性，属性值为 20000， 然后 ssh copy id, 别名"),o("br"),e._v("\n就可以在本地机，直接连接创建好的 docker，不用再先连到 服务器，在连到 docker")]),e._v(" "),o("li",[o("code",[e._v("adduser fw")]),e._v("  创建 fw 用户")]),e._v(" "),o("li",[o("code",[e._v("usermod -aG sudo fw")]),e._v("  为 fw 用户增加 sudo 权限")]),e._v(" "),o("li",[o("code",[e._v("usermod -aG docker fw")]),e._v("  为 fw 用户增加 docker 权限")]),e._v(" "),o("li",[o("code",[e._v("su fw")]),e._v("  即可正常使用")])]),e._v(" "),o("h2",{attrs:{id:"docker-给容器开放新的端口"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#docker-给容器开放新的端口"}},[e._v("#")]),e._v(" docker 给容器开放新的端口")]),e._v(" "),o("p",[e._v("第一步：再在服务器端增加容器的映射端口 80 443")]),e._v(" "),o("p",[e._v("然后登录运行容器的服务器：")]),e._v(" "),o("p",[o("code",[e._v("docker ps -a")]),e._v("  查看所有的容器，选择要进行更改的容器")]),e._v(" "),o("div",{staticClass:"language-sh extra-class"},[o("pre",{pre:!0,attrs:{class:"language-sh"}},[o("code",[o("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" commit CONTAINER_NAME IMAGE_NAME:1.0 "),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 将容器保存成一个新的镜像，将 container name 和 IAMGENAME 换成容器和镜像的名字")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" stop CONTAINER_NAME "),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 关闭容器")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" CONTAINER_NAME "),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 删除之前的容器")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 使用新建的镜像重新创建一个包含所有目标端口的容器：")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" run -p "),o("span",{pre:!0,attrs:{class:"token number"}},[e._v("20000")]),e._v(":22 -p "),o("span",{pre:!0,attrs:{class:"token number"}},[e._v("8081")]),e._v(":8081 -p "),o("span",{pre:!0,attrs:{class:"token number"}},[e._v("80")]),e._v(":80 -p "),o("span",{pre:!0,attrs:{class:"token number"}},[e._v("443")]),e._v(":443 --name CONTAINER_NAME -itd IMAGE_NAME:1.0\n")])])]),o("p",[e._v("如果提示端口被占用，执行命令  "),o("code",[e._v("ps aux | grep -i manage")]),e._v("  查看占用该端口进程的 pid，然后执行命令  "),o("code",[e._v("kill -9 具体的pid")]),e._v("  即可")])])}),[],!1,null,null,null);_.default=v.exports}}]);